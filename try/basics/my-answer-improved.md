# 기본기

- ✅: 괜찮은 설명, 잘 이해하고 있음, 제목->완료여부표시
- 😎: 설명 보충함
- ❌: 추가 수정 필요
- 🔥: 주의해서 보기

## 목차

- [기본기](#기본기)
  - [목차](#목차)
  - [JavaScript](#javascript)
    - [this란 무엇인가](#this란-무엇인가)
  - [구현](#구현)
  - [✅ 추가 내용](#-추가-내용)
  - [✅ 통신/API/브라우저](#-통신api브라우저)
  - [✅ 언어 패러다임](#-언어-패러다임)
  - [JavaScript](#javascript-1)
    - [✅ 일반](#-일반)
    - [✅ 🔥 this](#--this)
    - [✅ ES6](#-es6)
    - [✅ 🔥 비동기](#--비동기)
  - [React](#react)
  - [✅ Tools](#-tools)
  - [✅ TypeScript](#-typescript)
  - [✅ CSS](#-css)
  - [인성](#인성)
  - [그 외](#그-외)
  - [🔥 그 외](#-그-외)
  - [🔥 조직 차원 검증](#-조직-차원-검증)
  - [🔥 기본적으로 준비해가야 하는 질문](#-기본적으로-준비해가야-하는-질문)
  - [그 외 특이사항](#그-외-특이사항)
  - [참고자료](#참고자료)

## JavaScript

- 스코프
- 스코프 체인
- 클로져
- EC
- EC Stack
- VO (variable object, 변수객체, 활성객체)
- 프로토타입
- 프로토타입 체인
- 호이스팅
- 가비지컬렉터 알고리즘
  - reference-counting
  - mark-and-sweep
- 콜스택에 어떤 정보가 있는지
- js에서 object가 내부적으로 어떻게 저장 되는지
- 웹팩 관련 사용한 로더가 무엇인지
- 불변으로 상태관리를 하는 이유는 뭔지
  - 변경을 가하는 함수 내부에서 기존 상태를 변경하지 않으므로 변경 추적에 용이하다.
  - shallow rendering으로 비교해 그 값이 변경되었는지 파악가능 (레퍼런스가 변경되면 값이 변경되었다고 판단). 그렇지 않으면 내부를 모두 순회하며 비교해야함

### this란 무엇인가

this는 간단하게 표현해 this가 속한 객체를 나타내는 키워드라고 할 수 있다.

이 this는 어디서 쓰이느냐에 따라, use strict 여부에 따라 다르게 정의된다.

- 전역범위: 전역 객체, use strict -> undefined
- 함수: 전역 객체
- 객체의 메서드: 메서드의 객체
- 메서드의 내부 함수: 전역 객체
- 생성자: 새로운 객체

- 😎 use strict 모드에서의 this?
  - 2. this값이 원시값(primitive value)이라면, 비엄격모드일 경우 autoboxing이 수행됩니다. 하지만, 엄격 모드라면 수행되지 않습니다(=원시 값 그대로를 가집니다). this값이 Function.prototype.call 혹은 Function.prototype.apply에 의해 전달된 경우 또한 동일합니다.

## 구현

- map

  ```js
  const map = (arr, mapFn) => {
    const length = arr.length;
    const newArr = [];

    for (let i = 0; i < length; i++) {
      newArr.push(mapFn(arr[i]));
    }

    return newArr;
  };

  const numbers = [1, 2, 3];
  const result = map(numbers, (num) => num + 1);

  console.log(numbers, result); // 기존 numbers에 영향을 미치지 않고 새로운 배열이 나옴을 확인
  ```

- reduce

  ```js
  function reduce(arr, reduceFn, initValue) {
    let acc = initValue || 0;

    for (let i = 0; i < arr.length; i++) {
      acc = reduceFn(acc, arr[i]);
    }

    return acc;
  }

  reduce([1, 2, 3], (acc, cur) => acc + cur, 0); // 6

  Array.prototype.reduce = function (reduceFn, initValue) {
    return reduce(this, reduceFn, initValue);
  };
  [1, 2].reduce((acc, cur) => acc + cur, 0); // 3
  ```

## ✅ 추가 내용

- 😎 Node.js는 V8 자바스크립트 엔진으로 빌드된 자바스크립트 런타임 (실행환경)
- 😎 🔥 Node.js
  - 이벤트 기반: 특정 이벤트가 발생했을 때 호출될 함수를 지정하는 방식으로 동작, 이는 이벤트 루프를 이해 해야함
    - 이벤트 루프: 이벤트 발생 시 호출할 콜백 함수들을 관리 (반복적으로 실행 순서 결정하고 수행)
    - 태스크 큐: 이벤트 발생 후 호출되어야할 콜백들이 대기하는 곳
    - 백그라운드: 타이머나 IO 작업 콜백 또는 이벤트 리스너 대기
  - 논 블록킹 IO: 이전 작업이 완료될 때 까지 기다리지 않고 작업을 계속 수행. 현 노드 프로세스 외에 다른 자원을 사용할 수 있는 I/O 작업 등이 시간적 이득을 많이 봄
  - 싱글 스레드
    - 하나의 스레드에서 모든 작업이 일어남. (프로세스 - 운영체제에서 할당하는 작업의 단위, 프로세스 간에는 메모리 등의 자원을 공유하지 않음. 스레드 - 프로세스 내에서 실행되는 흐름의 단위, 스레드들은 부모 프로세스의 자원을 공유하여 같은 메모리에 접근 가능)
    - 실제로 노드에는 여러 스레드가 있지만, 개발자가 제어 가능한 스레드는 1개 뿐임
    - 컴퓨터 자원을 적게 사용하는 장점이 있지만, CPU 코어를 하나밖에 사용하지 못하는 단점
    - I/O작업은 논 블락킹으로 진행되지만, CPU 작업은 블락킹으로 작업됨
- 😎 쿠키와 세션
  - 쿠키는 단순한 키-값 쌍으로써 서버는 응답시 쿠키를 전달하고 브라우저는 쿠키를 전달받은 이후 부터 매 요청에 쿠키를 포함해 요청함
  - 쿠키는 요청자를 구분하기 위한 용도로 사용됨
  - 쿠키는 요청과 응답의 헤더에 저장됨
  - 세션은 정보를 실제 정보를 서버에 보관하고, 쿠키로는 정보에 매치되는 ID만 전달하는 방식
- 😎 헤더와 본문
  - 헤더: 요청 또는 응답에 대한 정보
  - 본문: 서버와 클라이언트 간에 주고받을 실제 데이터
- 😎 웹소켓
  - HTML5에서 추가된 스펙, 지속적으롱 연결된 라인을 통해 실시간 양방향 데이터 전송을 위한 기술

## ✅ 통신/API/브라우저

- 😎 HTTP 통신이란?
  - 어플리케이션 레벨의 프로토콜, TCP/IP위에서 동작한다.
  - 웹에서 데이터를 주고 받기 위한 통신 규약 중 하나로서 서버/클라이어늩 모델을 따른다.
  - HTTP는 요청/응답후 연결을 끊어 stateless하다.
- 📝 HTTP와 HTTPS의 차이는?
  - HTTPS는 SSL암호화하여 통신간에 데이터를 암호화하여 중간에 요청을 가로채더라도 그 내용을 확인할 수 없도록 하는 기술
- 📝 HTTP1.1과 2.0의 차이는?
  - HTTP2는 요청/응답 방식이 HTTP1.1에 비해 효율적으로 개선되어 수행됨
  - HTTP1.1
    - 연결당 하나의 요청과 응답을 처리
  - HTTP2.0 - Multiplexed Streams (한 커넥션에 여러개의 메세지를 동시에 주고 받을 수 있음) - 서버 푸시 기술 - HTTP 1.x의 HOL blocking 문제 해결 - HTTP 헤더 데이터 압축
  <!-- - 웹 프로토콜이란? -->
- 😎 `4` RESTful API에 대해서 설명해달라
  - REpresentational State Transfer
  - 주소는 리소스를 명사로서 나타내고, 이는 계층적으로 구성될 수 있음
  - 메서드는 주소로 명시된 리소스를 HTTP 메서드를 이용해 어떻게 조작할 것인가에 대한 문제를 정의함
    - GET: 자원을 가져옴
    - POST: 자원을 새로 등록
    - PUT: 서버의 자원을 요청한 데이터로 치환하는 경우
    - PATCH: 서버의 자원을 요청한 데이터로 일부 업데이트하는 경우
    - DELETE: 서버의 자원을 삭제
  - 기본적으로 위와 같이 API를 설계하는 것을 RESTful API라고 하나, 실제 어플리케이션 개발에서는 위 방법을 약간 벗어나 독자적인 규칙을 가지고 개발되는 경우도 있음
- 😎 🔥 CORS란? 왜 이 방법이 등장하였는가? 경험했던 이슈가 있는가?
  - Cross-Origin Resource Sharing
  - 대부분의 브라우저들은 보안 상의 이유로 스크립트에서의 cross-origin HTTP 요청을 제한한다 이를 "동일 출처 정책(SOP)"라고 한다. 이를 해결하기 위해 등장한 것이 CORS인데 다른 도메인간 자원을 공유할 수 있게 해주는 것으로 다음 헤더를 통해서 브라우저에게 허용여부를 알려준다.
    - Access-Control-Allow-Origin - 접근 가능한 url 설정
    - Access-Control-Allow-Credentials - 접근 가능한 쿠키 설정
    - Access-Control-Allow-Headers - 접근 가능한 헤더 설정
    - Access-Control-Allow-Methods - 접근 가능한 http method 설정
    - https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/FrontEnd#cors
  - 신규사업을 준비할 때 다른 도메인을 가진 페이지에서 API 서버로 요청하면서 경험을 해보았다. 그 때 관련 정보를 찾아보았고 위 규칙만 잘 이해하면 손쉽게 해결할 수 있었다. (서버에서 Access-Control-Allow-Origin 설정)
  <!-- - CORS 그리고 JSONP -->
- ✅ CSR vs SSR
  - CSR(Client Side Rendering)은 HTML의 구성과정이 클라이언트에서 일어나는 것을 의미한다. 브라우저가 서버에 경로에 대한 요청을 하면 전체 HTML 구조가 완성되어 있는 html 파일이 아니라 껍데기만 있는 파일을 받아 `<script />`에 있는 자바스크립트에 의해 동적으로 DOM이 추가되어 브라우저 상에 그려지게 된다.
  - SSR(Server Side Rendering)은 요청을 받은 서버에 의해 HTML 구조가 완성되어 클라이언트로 전달된다. 클라이언트는 파일을 파싱하는 즉시 표시할 수 있어 초기 렌더링이 더 빠른 것 처럼 보여진다. 전통적인 PHP, JSP, Ruby on Rails 등의 웹서버에서 사용하던 방식이 여기에 해당된다.
  - SPA 방식의 어플리케이션의 경우 특별히 SEO 또는 초기 렌더링에 성능적 문제가 발생하지 않는 경우 CSR만 적용해도 크게 문제 되지 않는다.
  - SEO만 필요한 경우, 이에 대한 처리만 서버에서 추가적으로 하도록 구성할 수도 있다.
- ✅ GET vs POST
  - GET과 POST는 HTTP 메소드로서 GET은 정보를 URL에 포함해 전달하는 반면, POST는 데이터를 body에 포함하는게 일반적이다. RESTful API에서 GET은 정보를 가져올 때, POST는 요청에 의해 리소스를 생성할 때 사용한다.
- ✅ `5` 브라우저가 렌더링되는 과정에 대해서 설명해주세요.
  - 사용자가 브라우저에 URL을 입력하고 HTTP 요청을 서버로 보내면 서버에서는 그에 해당하는 HTML 파일을 `Content-Type: text/html` 형식으로 브라우저로 응답한다. 브라우저는 이를 통해 HTML 형식으로 파싱해야하는 것을 인지하며 들어온 정보를 바이트 -> 캐릭터 -> 토큰화 -> 노드화 -> DOM 과정을 거치게된다.
  - DOM을 만드는 과정에 link나 script태그를 만날 수 있는데 이 두가지는 DOM 생성을 블락킹할 수 있다.
  - 먼저 script와 link가 지정한 외부 리소스를 다운로드하는 것 그 자체는 백그라운드에서 진행되기 때문에 DOM 생성을 직접적으로 블락시키지는 않는다.
  - 하지만 DOM을 생성하는데 있어서 js가 관여될 수 있기 때문에 브라우저는 DOM tree 생성을 중단하고 스크립트가 모두 다운로드 되고 실행을 마치기를 기다린 후에 DOM 생성을 재개한다.
  - 그래서 script의 위치는 body가 끝나지 전지점을 주로 추천하는데, HTML5에 들어서면서 꼭 그렇게 하지는 않아도 된다.
  - async와 defer가 있다. 둘다 script 태그를 만나도 DOM tree 생성을 블락시키지 않지만 async는 스크립트의 다운로드가 완료되는 즉시 DOM 생성을 중단하고 스크립트를 해석한다.
  - defer는 DOM생성이 종료되는 시점에 스크립트를 해석한다.
  - CSS는 직접적으로 DOM tree 구성을 블락시키지는 않지만 CSSOM이 Render Tree를 구성하는데 필수이기 때문에 브라우저는 결과적으로 CSS를 먼저 해석한다.
  - ❌ DOM과 CSSOM이 만들어지면 Render Tree를 구성하고 flow, paint 단계를 거쳐 브라우저에 그려진다.
  - ❌ 이 과정들은 CRP에 영향을 미치기 때문에 주의깊게 설계해야한다.
- 😎 🔥 `4` 브라우저 저장소에 대한 차이를 설명해주세요. (localStorage, SessionStorage, Cookie, IndexedDB 등...)
  <!-- https://medium.com/@lancelyao/browser-storage-local-storage-session-storage-cookie-indexeddb-and-websql-be6721ebe32a -->
  - 로컬스토리지는 영구 저장소이다. 명시적으로 데이터를 삭제하기 전까지 유지된다. (약 2MB)
  - 세션스토리지는 현재 세션이 종료(창이 닫힘, 탭이 변경됨)되는 즉시 저장된 데이터도 삭제된다. (약 2MB)
  - Cookie는 key-value쌍을 저장하며 4kb의 용량 제한이 있다. 쿠키는 보통 서버에서 사용자를 구별하기 위한 값으로 사용하므로 변조를 방지하기 위해 서버 할당시 http only로 설정해주는 것이 좋다. 만료기한 등을 설정할 수 있다.
  - indexedDB는 비교적 용량이 크다. objects과 key-value 쌍 모두 저장 가능하다. 이벤트 드리븐 방식으로 동작한다.
  - 위 모두 호스트 마다 각각 정보를 가진다. (same-origin policy를 따른다)

## ✅ 언어 패러다임

- 😎 OOP의 특징에 대해 설명하라
  - Object Oriented Programming, 객체 지향 프로그래밍으로서 프로그램을 디자인 할 때 실세계의 특징에 대입해 클래스를 구성하는 것을 말한다. 클래스는 프로퍼티와 메서드로 구성되며 프로퍼티는 속성, 메서드는 행동이라고 볼 수 있다. 오토바이를 예로 들면 바퀴개수는 속성, 시동을켜고 달리는것은 메서드이다.
  - 클래스 객체간에 메시지(메서드)를 주고 받는 방식으로 진행됨
  - 객체 지향적 설계 원칙
    - SRP - 단일 책임 원칙
      - 클래스의 변경 이유는 단 한가지 여야한다.
    - OCP - 개방폐쇄 원칙
      - 객체는 확장에는 열려있고 변경에는 닫혀있어야한다.
    - LSP - 리스코프 치환 원칙
      - 상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야한다. (즉, 주어진 인터페이스를 만족하면 정상적으로 동작해야함)
    - ISP: 인터페이스 분리 원칙
      - 인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야한다.
    - DIP - 의존 역전 원칙
      - 고수준 모듈은 저임준 모듈의 구현에 의존해서는 안된다. (각자의 역할이 있어, 외부에서 주입해 위임)
- 😎 함수형 프로그래밍의 특징에 대해 설명하라
  - OOP
    - class와 object에 기반한 프로그래밍 패러다임
    - 클래스는 상태를 가지며, 메서드를 이를 제어하는 형태로 동작한다.
    - mutable하다.
  - FP
    - side effect없는 순수함수를 구현함으로서 프로그램을 디자인한다.
    - immutable하게 데이터를 다룬다.
    - 함수는 1급 객체로 간주됨
- 😎 함수형 프로그래밍 개념에서 순수함수란?
  - 순수함수란 사이드이펙트(부작용)을 일으키지 않는 함수를 말한다. 입력이 동일하다면 출력은 항상 동일해야한다. 입력값이 변화하는 것도 사이드 이펙트이기 때문에 보통 입력을 복사하여 사용한다.
  <!-- - OOP vs FP의 차이점은? -->
- 🤢 반응형 프로그래밍이란?
  - 이벤트나 변화에 반응하기위해 비동기적 데이터 처리 및 흐름 기반 프로그래밍 패러다임
- ✅ 메모이제이션이란?
  - 계산 결과를 기록해두고 재사용하는 것을 의미한다.
  - 로직의 부하가 큰 경우 주로 사용하며, 한번 계산한 이후에는 메모해둔 값을 반환해 속도를 향상시킨다.
  - 코드에서는 메모이제이션이라는 용어로 쓰이고 다른 분야에서는 캐시라고도 한다.
- 😎 프로세스와 스레드의 차이는 무엇인가?
  - 프로세스 - 운영체제에서 할당하는 작업의 단위, 프로세스 간에는 메모리 등의 자원을 공유하지 않음.
  - 스레드 - 프로세스 내에서 실행되는 흐름의 단위, 스레드들은 부모 프로세스의 자원을 공유하여 같은 메모리에 접근 가능
  - 프로세스간의 스위칭 보다는 스레드간 스위칭이 더 빠르므로 멀티 스레드 사용 (+자원을 적게 사용)
  - 스레드는 자원을 공유하므로 동기화에 신경써야한다.
- ✅ call by value & call by ref
  - call by value: 값을 복사해 전달한다.
  - call by ref: 참조에 의한 호출이라고 하며 실제 값이 아니라 해당 변수가 가르키는 주소를 전달한다. 그래서 call by ref로 전달받아 변경하면 서로에게 영향을 미치게 된다.

## JavaScript

### ✅ 일반

<!-- https://bigstar-vlog.tistory.com/62 -->

- 😎 JavaScript의 Number type이 가지는 다른 언어와의 차이점은? 왜 하나만 존재하는가?
  - 다른 언어에는 int, double 등 숫자타입의 다양함이 있지만, JS는 모든 수를 실수(double)로 처리한다.
  - 64-bit format IEEE-754
- 😎 JavaScript의 원시 타입은 몇가지 인가?
  - number, string, boolean, null, undefined 5가지 (+Symbol 6가지)
  - null은 자료형이 객체이며 명시적으로 빈값을 의미
- 📝 `4` 실행 컨텍스트(Execution Context)에 대해 설명하라
  - 자바스크립트의 코드들이 실행되기 위환 환경이다.
  - 전역 컨텍스트와 함수 컨텍스트 2가지가 존재한다.
  - 전역 컨텍스트 생성 후에 함수가 호출할 때마다 함수 컨텍스트가 생성된다.
  - 컨텍스트 생성 시 변수객체, 스코프 체인, this가 생성된다.
  - 컨텍스트 생성 후 함수에 사용되는 변수들은 변수 객체 안에서 값을 찾고,
  - 없다면 스코프 체인을 따라 올라가며 찾는다.
  - 함수 실행이 마무리 되면 해당 컨텍스트는 사라지고, 페이지가 종료되면 전역 컨텍스트 사라진다.
- ✅ `5` 호이스팅이란?
  - 선언부가 함수 스코프의 최상단으로 끌어올려지는 것을 말함
  - 다음 두가지가 호이스팅 됨
    - var 변수
    - function을 통한 함수 선언
- ✅ `5` 클로저는 무엇인가? 왜 사용하는가?
  - 클로저는 이미 호출되어 종료된 함수 스코프 안의 변수를 가지고 있는 함수를 의미한다.
  - 이 때 그 변수를 자유변수라 부른다.
  - 보통은 모듈내 고립시키기 위한 목적으로, 외부의 조작으로부터 자유변수를 올바르게 제어하기 위한 목적으로 클로저를 사용한다. 또는 특정 모듈의 상태값으로 사용될 수도 있다.
- ✅ GC의 역할은 무엇이며 어떻게 동작하는가?
  - GC는 더이상 참조되지 않는 객체를 메모리에서 해제하는 역할을 한다.
  - root 객체에서 더이상 연결되지 않는 객체들을 메모리에서 해제한다.
- 😎 JavaScript에서 순환참조란? 문제점과 해결방법을 설명하라
  - 자바스크립트는 모듈 순환참조를 허용한다.
  - 모듈은 위에서 아래로 해석되어 모듈을 참조하기 때문에 그 순서가 중요하다. 그래서 의존 관계에 따라 모듈을 가져오는 순서를 수정해주는 것이 해결방법이 되겠다.
  <!-- - ❌ JavaScript의 배열은 실제 배열 자료구조가 아닌데 그 이유는?
  - (문제의 의도가 유사배열을 말하는건가?) -->
- ✅ 프로토타입이란?
  - 프로토타입은 객체 생성시 `__proto__`로 연결되는 객체이다.
  - 예를들어 function Foo() 의 prototype이 `const a = {}` 라면 `const b = new Foo()` 하면 `b.__proto__`는 `a`가 된다.
  - 이런 특성을 이용하면 클래스 상속 같은 문제를 흉내내 해결할 수 있다.
- ✅ null vs undefined
  - null은 명시적으로 값이 없음을 나타낸 것이며 타입은 객체이다.
  - undefined는 아직 값이 설정되지 않았음을 나타낸다.
- ✅ 메서드 체이닝이란 무엇이며, 이에 대한 장/단점은?
  - 사용하기 편리하고 코딩시 보기가 좋으나
  - 디버깅시 그 오류 위치를 파악하기 힘들다.
- 🔥 이벤트 위임이란?
  - event delegation
- 🔥 `4` 이벤트 버블링이란? (bubbling? capturing?) 이를 잘 사용하려면?
  - 이벤트 버블링이란 이벤트 발생시 DOM 트리를 타고 부모로 이벤트가 전달되는 것을 의미한다.
  - 하위 트리에서 이벤트가 발생하면 부모트리까지 전달되기 때문에 부모에서 그 이벤트를 처리해도 무방하다.
  - 🤢 (캡쳐링은 ... 이벤트 발생요소를 찾는 과정인데... 뭐라고 설명할까)
  <!-- - DOM을 건드리는 방식과 아닌 방식들의 차이를 알려달라 -->
- 😎 `4` 웹워커?
  - 브라우저에서 멀티 쓰레드를 활용할 수 있다.
  - 비용이 많이 드는 작업을 메인스레드에서 처리하지 않고 웹워커에서 처리하고 처리가 완료되면 이벤트를 통해 콜백을 수행하도록 처리할 수 있다. 작업을 병렬로 수행할 수 있기 때문에 무거운 작업을 진행한다면 추천되는 방법이다.
  - 대신 브라우저 지원여부와 직접적으로 DOM접근을 못하는 등의 제약을 확인하고 개발해야한다.
- ✅ require와 import의 차이점?
  - require는 commonjs, import는 ES6 표준 모듈을 가져오는 방법이다.

### ✅ 🔥 this

> https://blex.me/@yoyounn18/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EC%A7%81%EA%B5%B0-%EC%9B%B9%EA%B0%9C%EB%B0%9C%EC%9E%90-%EB%A9%B4%EC%A0%91%EC%A7%88%EB%AC%B8-%EB%AA%A8%EC%9D%8C-%EB%8B%B5%EB%B3%80-%EB%8B%AC%EC%95%84%EB%B3%B4%EA%B8%B0

- ✅ 일반함수의 this와 화살표 함수의 this는 어떻게 다른가?
  - 일반함수의 this는 함수가 생성자로 사용되면 새로운 객체를 가르키고, 메서드로서 호출되는 경우 호출한 객체를 함수로서 호출되는 경우 전역객체를 가르킨다
  - 화살표 함수의 this는 존재하지 않으며 상위 함수 스코프의 this를 가르킨다.
- 😎 call, apply, bind에 대해서 설명하라
  - call, apply 모두 this context를 전달하는 동시에 호출하는 방법이다. 차이는 call은 (this, arg1, arg2, ...) 형태인 반면 apply는 (this, [arg1, arg2, arg3, ...]) 형태이다.
  - this가 함수 호출식에 따라 객체를 가르켰다면 call apply bind는 함수가 직접 실행문맥을 결정한다. 그 중에 call, apply는 함수를 호출해 실행한다. call apply를 사용했을때의 장점은 첫번째 인자가 없더라도 에러없이 실행이 가능하다(자동으로 전역객체를 지정하여 실행) bind는 지정한 객체의 함수를 만든다. 정리하면 call apply는 함수를 실행시켜주는 것이고, bind는 새 함수를 만들어주는 것이다.

### ✅ ES6

- 😎 브라우저가 ES6를 지원하지 않는 경우 해결방법은 무엇인가?
  - polyfill을 이용하거나 babel을 이용해 원하는 버전으로 미리 트랜스파일한다.
  - 두 방법에는 약간의 차이가 있는데
    - polyfill은 ES6 스펙 중 현재 존재하는 언어 스펙으로 기능을 이미 있는 것처럼 구현하는 것을 말한다. 예를 들면 `Array.forEach` 같은 것들이다.
    - 트랜스파일은 언어 수준에서 지원되지 않는 것을 다른 환경(ES6 -> ES5)에서도 동작하도록 코드를 변경해주는 것을 의미한다. 아직 비표준인 것도 가능하다. 예를 들면 `arrow function`, `JSX` 같은 것들을 타겟 환경에서 구동가능한 코드로 변환해준다.
- 😎 🔥 Babel이란?
  - JavaScript 트랜스컴파일러로서 주로 ES2015 이상의 코드들을 이전 버전 호환이 가능한 코드로 변환해주는 역할을 하는 툴이다.
- 😎 Babel은 컴파일러인가 트랜스파일러인가?
  - 공식 홈페이지에서도 "트랜스컴파일러"라고 하며, 커뮤니티에서도 혼용되어 불리긴 한다. 하지만 컴파일러가 고수준의 언어를 저수준의 언어로 변환하는 것에 반해, 트랜스파일러가 비슷한 추상화의 언어로 변환된다는 것을 생각하면 아직 까지는 트랜스파일러에 가깝다고 볼 수 있다.
- 😎 ES6에서 추가된 스펙은 어떤게 있는가?
  - let, const
  - 템플릿 문자열
  - 객체 리터럴
    - 1. 객체의 메서드에 함수 연결시 `{ prop: function () {} }`를 `{ prop() {} }` 으로 작성 가능
    - 2. 속성명과 할당되는 변수 명이 동일한 경우 속성명만 기술해도 무방
    - 3. 객체 속성명을 동적으로 생성 가능 `{ [a + b]: ... }`
  - 화살표 함수
  - 비구조화 할당
  - Promise (then 메서드들은 순차적으로 실행, 콜백에서 매번 처리해야 했던 에러도 마지막 catch에서 한번에 처리 가능)
  - async/await (ES2017)
    - for문과 async/await를 함께 사용해 Promise.all 대체 가능 (ES2018)
      `for await (promise of [promise1, promise2])`
- ✅ var, let, const의 차이는 무엇인가? (function scope와 block scope의 개념에서)
  - var는 함수 스코프를 가지며 실행 컨텍스트 생성시 함수 최상단으로 선언이 호이스팅됩니다.
  - let과 const는 블록 스코프를 가지며 호이스팅 되지 않습니다.
  - let은 초기화 후 재할당이 가능하지만
  - const는 초기화만 가능하고 재할당은 불가능합니다.
- ✅ class는 무엇이며 prototype, function의 ES5 스펙만으로 class 구현이 가능한가?

  - class는 어떤 개념을 속성과 동작으로 묶어 표현한 것이며 상속의 개념이 있습니다.
  - ES5로 충분히 class와 같은 개념을 흉내낼 수 있으며 간단한 예시는 다음과 같습니다.

    ```js
    function Duck() {
      this.speak = () => console.log("꽥");
    }

    function FlyingDuck() {
      this.fly = () => console.log("날아요~");
    }

    const duck = new Duck();
    FlyingDuck.prototype = duck;
    const flyingDuck = new FlyingDuck();

    flyingDuck.speak(); // 꽥
    flyingDuck.fly(); // 날아요~
    duck.speak(); // 꽥
    duck.fly(); // Error! fly undefined
    ```

### ✅ 🔥 비동기

- 😎 AJAX란 무엇인가?
  - Asyncronous Javascript And XML
  - 비동기적 웹 서비스를 개발하기 위한 기법, 이름과 다르게 꼭 XML을 사용해야하는 것은 아님
  - 간단히 말해 페이지 이동 없이 서버에 요청을 보내고 응답을 받는 기술
- 😎 Promise와 Callback의 차이점은 무엇인가? 각각의 장단점은?
  - https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/JavaScript#promise
  - Promise는 fullfill, reject 두가지 상태로 귀결되면 then 또는 catch에 의해 다음 호출이 핸들링 되는 기법
  - Callback은 어떤 함수의 인자로 함수를 받아 로직의 특정한 구간에서 이 함수를 실행하는 기법
  - Promise는 처음보면 이해가 어려울 수 있으나 콜백지옥에 빠지지 않아 가독성이 좋다
  - 반면 Callback은 단순히 함수 호출을 따라가면 되기에 로직을 이해하기 쉬울 수는 있으나, 수많은 콜백이 중첩되는 경우 코드가 화면 우측을 뚫고나가 `>` 모양으로 코드가 구성될 수 있다. 이는 보기에도 안좋을 뿐더러 이해하기도 더 어려운 코드가 되어 단점이 된다.
- 😎 Promise란 무엇이며 코드가 어떻게 구성되는가?

  - Promise는 동작의 이행상태에 따라 fulfill, reject 로 귀결되며 다음과 같이 구성된다.

    ```js
    const promise = new Promise((resolve, reject) =>
      로직성공 ? resolve(반환값) : reject(에러)
    );

    promise.then((반환값, 에러) => {
      // 성공, 두번째 인자로 에러처리를 할 수도 있다.
    }).catch(((에러) => {
      // 에러시 처리
    }).finally(() => {
      // 성공/실패 여부에 상관없이 실행됨
    })
    ```

- 😎 `4` Async/Await가 무엇인가?

  - 비동기를 동기코드 처럼 작성하게 해주는 기법이다. 다음과 같이 작성한다.await는 async함수 안에서만 사용할 수 있는 제약이 있다.
  - https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/JavaScript#asyncawait

  ```js
  async () => {
    try {
      const 반화값 = await 비동기함수();
      // 성공 제어
    } catch (err) {
      // 에러 제어
    }
  };
  ```

그래서 코드 최상단에서 사용되는 경우 IIFE를 활용한다.

```js
(async () => {
  await 비동기함수();

  // 그 외 로직들
})();
```

- 😎 `4` Async/Await vs Promise 차이는?
  문법의 차이이다. Promise를 이용한다는 점에서는 같다.

## React

- 리액트의 상태관리에 대해서 알고 있는가? 리덕스를 사용해 봤다면 그에 대한 설명
- Redux-saga의 observable에 대해서 들어봤는가?
- Context API에 대해서 설명하시오.
- 클래스형과 함수형의 차이는 무엇인가?
- 라이프사이클 메서드에 대해서 설명하시오.

## ✅ Tools

- 🔥 ESLint란?
  - JavaScript 코드를 정적 분석하는 툴
  - 정해진 규칙에 어긋나는 코드는 없는지 확인하고 경고해줌
  - 일부 규칙은 자동으로 fix가 가능한 경우도 있음
- 🔥 Prettier란?
  - 코드를 정해진 규칙에 따라 일관성 있게 포맷팅 해줌
  - 포맷팅 컨벤션에 대해서 신경쓰지 않아도 되어서 좋음
  - 여러 사람이 작업할 때 특히 동일한 포맷으로 diff가 크게 변하지 않음으로 리뷰시에도 좋은 효과를 냄
- 🔥 Webpack이란?
  - 모듈 번들러. 말이 어렵지만 여러 모듈을 묶어 하나의 파일로 만들어 주는 것을 의미함.
  - 웹팩은 JS 생태계에서 가장 인기있는 번들러로서 최근에 뜨는 대안으로는 parcel이 있다. 하지만 두 라이브러리가 추구하는 방향은 약간 다른 것같다.
  - parcel은 약간 No configuration을 추구한다.
  - 반면 웹팩은 여러 설정이 필요해 진입장벽이 높아 보이지만 막상 실행하보면 별게 없다.
  - entry로 지정한 파일에서 의존성을 분석하고 각 의존성이 어떤 모듈을 불러들이는지에 따라 각기 다른 로더들이 관여해 어떻게 처리할지 결정한다.
- ✅ 🔥 npm과 yarn의 차이는?
  - npm - npm에서 관리하는 패키지 매니징 툴
  - yarn - facebook에서 만든 패키지 매니징 툴
  - yarn이 초기 속도가 빨랐으나 지금은 크게 차이가 나지 않음
- ✅ package.json의 역할은 무엇인가?
  - 패키지에 관한 정보와 의존성에 대한 정보를 담고 있음
  - 의존성, 저자, 앱이름, 키워드, 설명 등...
  - 도대체 왜 기록하는가 싶지만 npm에 배포되면 그 내용이 빛을 발한다.
  - 보통 개발시에는 script, dependencies 정도를 많이 확인하게 된다.
  - 그 외에 jest 등의 설정도 포함할 수 있다.
- 📝 package.json에서 dependencies와 devDependencies의 차이는?
  - `dependencies` 패키지의 배포 시 포함될 의존성 모듈
  - `devDependencies` 패키지의 개발 시 사용될 의존성 모듈 (배포 시 포함되지 않음)
  - `peerDependenceis` 패키지의 호환성 모듈을 지정. 직접 사용하지는 않지만 호환되는 패키지의 목록, 주로 어떤 패키지의 플러그인 등을 개발할 때 명시 (react-... 등)

## ✅ TypeScript

- 타입스크립트에 대한 경험이 있는가? 타입스크립트에 대한 생각과 도입시 장점은?
  - 프로젝트가 커져서 기억만으로 커버가 되지 않을 것이라고 생각될 때, 타입스크립트를 사용
  - 그렇지 않더라도 가능하면 타입스크립트를 사용하려 함
  - 타입을 정의하는 일이 귀찮은 작업이긴 하지만 익숙해지면 타입은 정말 눈깜짝할 새 작성하기도 하고 타입이 주는 이점은 auto complete가 신속히 진행되는 점 뿐만 아니라 리팩토링시에나 클래스간에 인터페이스를 정의할 때 실수할 여지를 줄여주기도 해서, 결과적으로 실행전에 많은 오류를 발견하고 고칠 수 있기에 선호
  - 타입 그 자체로 어느정도 문서화가 되기 때문에 특히나 여러사람이 함께하는 프로젝트에서 빛을 발한다고 생각함

## ✅ CSS

- ✅ inline vs inline block
  - inline은 content에 크기가 맞춰짐
  - inline-block은 크기, 마진, 패딩 지정이 가능함
- 😎 적응형과 반응형의 차이는 무엇인가?
  - 적응형
    - 서버 또는 브라우저에서 기기 감지
    - 기기에 따라 필요한 컨텐츠만 다운로드
    - 기기마다 다른 템플릿
  - 반응형
    - 미디어쿼리를 통해 감지
    - 모든 기기에서 동일한 컨텐츠 다운로드
    - 하나의 템플릿
  - `m.*`인 홈페이지가 보통 적응형이라고 볼 수 있는데 따로 구분해 스탠드어론이라고 부르기도 함
- ✅ margin vs padding
  - 마진은 엘리먼트 간의 간격이며 collaspe되는 성질을 가짐
  - padding은 border와 content 사이의 간격
- 😎 position을 사용하는 방법 (질문이 애매하다)
  - static, relative, absolute, fixed
    - relative는 static 위치에 상대적
    - absolute는 static이 아닌 가장 가까운 부모의 위치로 부터 계산
    - fixed는 뷰포트 기준
- 😎 box model이란?
  - 문서의 레이아웃을 계산할 때, 브라우저의 렌더링 엔진은 표준 CSS 기본 박스 모델에 따라 각각의 요소를 사각형 박스로 표현함. 다음 4가지 구성요소로 이루어짐
    - margin
    - border
    - padding
    - content
- 😎 sass와 css의 차이점
  - sass(정확히는 SCSS)는 preprocessor로서 css를 호환하는 문법을 따로 가지며, 전처리를 거쳐 css를 산출물로 낸다.
  - CSS의 유지보수가 힘든점을 개선한 방법이라고 볼 수 있다.

## 인성

- 왜 개발자가 되려고 하는가
  <!-- - 내 제품이 다른사람들 품으로가 피드백을 받는 그 과정이 좋다.
  - 돈을 받는 상품이긴 하지만, 세상을 이롭게 하는 기분이 든다. -->
- 개발자로서의 본인의 비전을 이야기 해달라
  <!-- - 개발자들에게 효율적인 도구를 제공하는 개발자가 되면 좋겠다.
  - 그리고 후배 개발자들이 내가 했던 실수를 반복하지 않도록 도와주고 싶고 동료들에게도 내가 아는 것을 널리 알려주고 싶다.
  - 이 모든건 훌륭한 제품을 만드는데서 시작한다. -->
- 운영체제같은 컴퓨터공학(cs)에 대한 기초지식이 있는가
  <!-- - 🤢 대략적으로 알긴한데... 뭔가 설명하려니 어떡해야할지 모르겠다 😂 -->
- 최근에 관심갖거나 공부 하고 싶은 개발 기술은 무엇인가
  <!-- - p5js를 해보고 싶다. 대학때 OpenGL로 태양계를 그리고 perspective를 조작하고 하는 프로젝트를 조금 해봤었는데 재밌기도 했고 이게 웹에서 돌아간다면 정말 다양한 시도를 해볼 수 있을 것같다.
  - 그 외에는 새로운 분야보다는 자바스크립트 그 자체를 어떻게 더 잘 사용할 것인가에 대한 공부를 계속 하고싶다. -->
- 프로젝트 협업 과정을 경험한 적이 있는가
  <!-- - (대학 시절부터 쭉 얘기하면 되겠다. 방금 조금 얘기해보니 한시간은 말할 수 있을 것같다. 임팩트 있는 부분들을 추리도록 해야겠다) -->
- 공부 방법
  <!-- - 개발자가 되기 위해서 어떻게 공부하였는가
  - 학습시 주로 이용하는 웹페이지나, 동영상 강좌 페이지는 어디인가
    - 학습을 하기위한 공식사이트가 있다는 그곳을 가장 먼저 이용한다.
    - 유튜브 같은 것도 잘 되어 있지만 편하긴 하지만 기억에 잘 남지 않고 직접 문서를 보면서 쳐보는게 더 빠르고 기억에도 잘 남는다. 그리고 공식문서가 요즘은 굉장히 잘 되어있는 것같다.
    - 그래도 부족하면 구글링을 추가로 해보고 영상/문서 할 것없이 보는 편이다.
    - 트렌드 같은건 Medium 뉴스레터에서 많이 읽게 되는 것같다.
    - 너무 막히면 Udemy같은 강의 사이트도 결제해보곤 하는데 크게 도움은 되지 않는다.
    - 가장 최근에는 fastcampus에서 FE관련 세션 2개를 결제해 들어보았다. -->
  - 최근의 읽은 개발 관련 서적은 무엇인가
    <!-- - 인사이드 자바스크립트
    - 자바스크립트 테스트와 패턴 -->
  - 즐겨 보는 개발 관련 유튜브가 있는가
    <!-- - funfunfunction, devtips
    - dev web simplified
    - jsconf -->
  - 회사 기술 스택에 맞추어 단기간 내에 언어와 프레임워크를 학습 하여야 할 때, 어떻게 공부하고 해결할 것인가
    - (머리속에 있다)
      <!-- - 포트폴리오 제작시에 비인기 라이브러리를 사용한 경험이 있는가 -->
      <!-- - 이러한 비인기 라이브러리에 대한 정보를 어디서 얻는가 왜 활용하였는가 -->
- 본인이 현재 FE를 주제로 발표할만한 것이 있을까?
  - (머리속에 있다)
- 시간이 있다면 FE 향상을 위해서 어떤 노력을 할 것인가?
  - (머리속에 있다)

## 그 외

- 배포를 해본적이 있는가? 어떻게 배포를 해보았는가?
- 두 명의 프론트엔드 개발자가 있을 때 git 관리 방식은?
- 라이브러리 vs 프레임워크 무엇이 다른가?
- JavaScript 성능 최적화를 해본 경험이 있는가?
- MVVM 에 대해서 설명해주세요.
    <!-- - Vue vs React 무엇이 다른가? -->
    <!-- - 현재 사용하는 프레임워크와 선택이유 -->
    <!-- - 최근 유행하는 프레임워크들과 차이점, 장단점은? -->
    <!-- - Angular와 React의 차이는 무엇이라고 생각하는가? -->

## 🔥 그 외

아래는 https://joshua1988.github.io/web-development/interview/frontend-questions 를 참고 하였음

- 프런트엔드 개발은 지속적으로 학습해야 하는 분야인데 어떤식으로 학습을 하고 있는지?
- 자바스크립트 프레임워크를 써봤는지? 써봤다면 어떤 걸 쓰는지? 만약 쓴다면 쓰는 이유와 썼을 때의 장점?
- “기획 - 디자인 - API 개발 - 프런트엔드 개발”의 서비스 절차에서 프런트엔드 개발자의 역할은 무엇이라고 생각하는지?
- CORS란? CORS를 해결하기 위한 방법을 아는 대로 모두 설명해 주시고 보통 어떤 방식으로 해결하는지 자주 사용하는 방법 1가지와 함께 실제 해결하신 경험을 공유해 주세요.
- 프런트엔드 성능 최적화란? 프런트엔드 성능 최적화 경험이 있다면 자세하게 설명해달라.
- 백엔드 개발 경험이 있는가?
  - (꼬리 질문) REST API 구축 경험과 구현 관점에서의 간단한 REST API 설계 방식 설명해 보세요. 브라우저의 URL 요청을 받아서 서버의 데이터를 화면에 다시 뿌려주기까지의 백엔드 쪽의 플로우를 알고 있는지 확인하는 차원.
- Virtual DOM이 뭔지 아시는지? 썼을 때의 장점?
- (꼬리 질문) 브라우저 동작 원리 아는 만큼 설명
- 웹 서비스 배포 시스템 구축 경험?
  - (꼬리 질문) CI, CD가 무엇인지 아는지? 구축해본 경험 혹은 사용해본 경험이 있는지
- 테스트 자동화 경험? 단위 테스트 또는 E2E 코드를 작성해 본적이 있는지?
  - (꼬리 질문) 테스팅 라이브러리와 프레임워크에 특화된 테스팅 라이브러리는 각각 어떤 걸 썼는지?
  - (꼬리 질문) 테스트 대상과 커버리지는 보통 어떻게 잡는지?
- 웹 접근성과 시맨틱 마크업이란? 이 2가지를 지키기 위해 보통 어떤식으로 마크업을 작성하는지?
- 웹 서비스를 기획부터 배포까지 모두 스스로 해본 경험이 있는가? 토이 프로젝트나 회사 서비스 등
  - (꼬리 질문) 구체적으로 어떤 역할을 수행했는지 설명
- SEO(검색 엔진 최적화)란? 적용 사례가 있으면 구체적인 적용 방법도 같이 설명
- REST API로 받은 객체와 배열은 보통 어떤 자바스크립트 API나 로직을 이용해서 화면에 맞게 가공을 하는지?
  - (꼬리 질문) map, filter, reduce API 사용 경험과 각각 설명
- 함수형 프로그래밍이란?
  - (꼬리 질문) 자바스크립트 클로저란?
  - (꼬리 질문) 자바스크립트 프로토타입이란?
- 서버 사이드 렌더링과 싱글 페이지 애플리케이션의 차이점?
  - (꼬리 질문) 서버 사이드 렌더링이나 SPA로 각각 구현해 본 경험이 있는지?

## 🔥 조직 차원 검증

- 타입 시스템에 대해서 알고 있는지? 타입스크립트를 써봤는지?
  - (꼬리 질문) 자바스크립트와 타입스크립트의 차이점?
  - (꼬리 질문) 타입스크립트의 장점과 단점?
- 웹 서비스의 사용성을 개선하기 위해 고민해 봤던 부분이 있는지? 구체적인 사례와 경험 설명
- 자바스크립트 관련해서 모르는 문법이나 API가 나왔을 때 관련 정보를 어떻게 검색하는지?
- 다른 직무의 동료들과 어떤 식으로 커뮤니케이션 하는지?
- 여태까지 소속되었던 팀 내부적으로 혹은 회사 외부적으로 지식 공유나 지식 전파 같은 활동들을 해본 적이 있는지?
- 새로 배우는 개발 지식은 보통 어떤 식으로 정리하는가?
- 코딩 컨벤션은 보통 어떤 걸 따르고 코딩 컨벤션을 프로젝트에 적용하기 위해 어떤 노력들을 하는지?

## 🔥 기본적으로 준비해가야 하는 질문

- 이 직무로 지원한 이유?
- 이 직무로 지원했을 때 하는 일에 대해서 얼마나 조사 및 이해를 하고 왔는지?
- 이직하려는 회사의 직무에서 기대하는 부분과 기여할 수 있는 부분?

## 그 외 특이사항

- [프론트엔드 면접 핸드북](https://blog.rhostem.com/posts/2020-04-13-fe-interview-handbook-js-2)

  - attribute와 property
  - 27. 다음의 함수를 구현하기
  - 31. SPA 앱이 무엇인지, 그리고 SEO는 어떻게 해야 하는지
  - 35. 자바스크립트 개발에 어떤 디버깅 툴을 사용하는지?
  - 36. 객체 속성, 배열 항목 반복(iterate)에 어떤 방법을 사용하는가?
  - 37. mutable, immutable 객체의 차이점

- [프론트엔드-개발자-인터뷰-후기-면접-질문](https://velog.io/@tmmoond8/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90-%EC%9D%B8%ED%84%B0%EB%B7%B0-%ED%9B%84%EA%B8%B0-%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8-%EC%A0%95%EB%A6%AC-%EC%9E%91%EC%84%B1-%EC%A4%91)

  - float을 해제하지 않으면 안되는 이유
  - css 애니메이션과 js 애니메이션 차이

- [채용 과정 후기](https://gtedha.github.io/2019/09/12/kakao-recruitment-review-4/)
  - 지원 동기
  - 지금껏 해온 일에 대한 설명 (설계 및 구현 내용에 관하여)
  - 다룰 수 있는 언어의 종류
  - 기존 회사에서 겪었던 문제점들과 해결하려고 시도했던 노력
  - Git 사용 관련
  - OS 관련된 내용
  - 검색 시스템과 관련한 지식

## 참고자료

- [Technical Interview Guidelines for Beginners](https://github.com/JaeYeopHan/Interview_Question_for_Beginner)
- [프론트엔드 개발자 면접 질문(기술면접) 정리](https://sunnykim91.tistory.com/121)
- [프론트엔드 면접 질문 모음](https://velog.io/@honeysuckle/%EC%8B%A0%EC%9E%85-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8-%EB%AA%A8%EC%9D%8C)
- ⭐️ [프론트엔드 개발자 기술면접 인터뷰 질문 모음](https://realmojo.tistory.com/300)
- X [프론트엔드 면접 문제 은행](https://h5bp.org/Front-end-Developer-Interview-Questions/translations/korean/)
- X [프론트엔드 인터뷰 핸드북](https://github.com/yangshun/front-end-interview-handbook/tree/master/contents/kr)
- X [프론트엔드 직군 웹개발자 면접질문 모음 답변 달아보기](https://blex.me/@yoyounn18/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EC%A7%81%EA%B5%B0-%EC%9B%B9%EA%B0%9C%EB%B0%9C%EC%9E%90-%EB%A9%B4%EC%A0%91%EC%A7%88%EB%AC%B8-%EB%AA%A8%EC%9D%8C-%EB%8B%B5%EB%B3%80-%EB%8B%AC%EC%95%84%EB%B3%B4%EA%B8%B0)
- X 1~3년 [프론트 엔드 기술 면접 질문 리스트](https://frontdev.tistory.com/entry/%ED%94%84%EB%A1%A0%ED%8A%B8-%EC%97%94%EB%93%9C-%EA%B8%B0%EC%88%A0-%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8-%EB%A6%AC%EC%8A%A4%ED%8A%B8)
- X 이전글이 좋음 [DevOwen의 구직 이야기 Ch4. 기술 인터뷰](https://devowen.com/297)
- X 경험글 [프론트엔드 개발자의 이직, 면접 경험 3](https://medium.com/@deptno/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%9D%98-%EC%9D%B4%EC%A7%81-%EB%A9%B4%EC%A0%91-%EA%B2%BD%ED%97%98-3-95a770383dc6)
