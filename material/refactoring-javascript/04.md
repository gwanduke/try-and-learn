# 4장

## 4.2

- TDD, 테스트 코드를 작성하고 코드를 작성해 그 인터페이스를 만족했다면 코드의 생김새가 어떠하든 우선은 Green을 만드는 것이 목표
- 리팩토링은 그 이후의 과정이다.
- 이 시점에서는 단순한 if, for. 복사&붙여넣기가 정말 좋은 선택이다.
- 중요한 것은 각 기능을 함수로서 처리를 하는 것 (작은 테스트를 동반하며)

## 4.3

- 코드 변경전에 테스트가 없다면, 테스트를 추가하는 것이 먼저다.
- 특성화 테스트를 진행하자.
  - 이는 `expect(something()).toBe(true)`처럼 무의미한 assertion을 통해 실제 값을 테스트를 통해 print하고 해당 assertion에 대체 해넣는 일
  - 또는 해당 함수가 가지는 특징, 예를 들면 `result.length === 4`와 같은 특징을 최소한의 테스트로 구성하는 것
- 함수가 아닌 파일 레벨에 부분들은 가능한 함수 내부의 변수로 return 처리등을 하도록 변경해주는 것이 테스트를 구성하기에 용이
- 고수준 테스트 (예를 들면, private 함수가 아닌 public API)는 가능한 명확한 특징을 뽑아 테스트를 작성하도록한다. (정규 표현식 처럼 애매한 처리를 지양)
- 레거시 코드에서 모든 범위에 대한 테스트를 작성하는 것은 비현실적. 이 경우 우선순위가 높은 구역을 대상으로 작성하는 것이 현실적.
- 전통적인 코드를 작성한(테스트가 없거나 검증이 힘든) 개발자를 탓해선 안된다. 그 시람은 비지니스를 더 잘 이해하고 있을 것이다.
  (옳은 생각이라고 생각한다. 정말 흔히들 잘 못 생각하는 것들 중에 하나라고 생각하는데, 비지니스의 목적이 있기에 코드가 있지 코드를 위해 비지니스가 있는게 아니다. 비지니스를 잘 이해한다는 것은 비지니스, 서비스에 대한 이해 그 자체도 있지만 그 당시의 목표, 시간을 위한 기술적 선택사항들을 포함한다고 생각한다.)

## 4.4 디버깅과 회귀 테스트

- 코드 작성, 변경전에 항상 테스트를 작성하자
- 느린 테스트를 위해 test를 test runner의 regex를 통해 실행하도록 하는 전략도 괜찮다. (\*.slow.test.js 처럼 구성해서)
- 테스트도 리팩토링할 수 있다. 첫 테스트는 반복문이나 if문을 통해 입/출력을 테스트해도 괜찮다.
- 앞서 소개했던 `expect(something()).toBe(true)` 형태의 테스트로 console.log 대신 결과값을 볼 수 있다. 첫 테스트는 이 결과값으로 대체해도 좋다.
- 적색 - 녹색 주기를 반복하자
- 느린 임시 테스트를 없애려면, 임의성에 의존하지 않는 함수의 구현을 테스트하는 것이 중요하다. (랜덤값을 사용하지 말라는게 아니라, 랜덤값을 사용하는 함수를 구성하고 이 함수가 반환하는 값이 실행시마다 나오는 결과가 예측가능하도록 구성하란 말. 책 예제의 경우 반환되는 결과의 형태, 인자로 받은 배열과 반환되는 배열의 크기차이를 테스트함) _125p_
- 비공개 함수를 테스트해야할까? -> 대부분의 사람들이 아니라고 한다. 왜냐면 코드 동작은 외부 함수로 테스트되어야하기 때문. 그리고 인터페이스가 아닌 구현을 테스트하는 것은 불필요하고 불완전한 테스트가 될 수 있다.
- 안전하게 리팩토링 주기에 도달했다면, 죽은 코드를 제거하자.
- 만약 인터페이스의 변경 (함수나 인자의 변경)이 있는 경우 이에 대한 테스트 작성은 필수다.
- 하지만 리팩토링 주기에 도달했다면, 구현부를 변경하는 것은 이제 자유다.
