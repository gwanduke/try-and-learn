# The Complete JavaScript Course 2020: From Zero to Expert!

- ❌ - 해야할 것 / 미완료
- ✅ - 완료
- 🔥 - 중요

## 목차

- [The Complete JavaScript Course 2020: From Zero to Expert!](#the-complete-javascript-course-2020-from-zero-to-expert)
  - [목차](#목차)
  - [❌ 복습 및 정리](#-복습-및-정리)
  - [✅ 섹션 1: Welcome, Welcome, Welcome!](#-섹션-1-welcome-welcome-welcome)
  - [✅ 섹션 2: JavaScript Fundamentals – Part 1](#-섹션-2-javascript-fundamentals--part-1)
  - [✅ 섹션 3: JavaScript Fundamentals – Part 2](#-섹션-3-javascript-fundamentals--part-2)
  - [✅ 섹션 4: How to Navigate This Course](#-섹션-4-how-to-navigate-this-course)
  - [섹션 5: Developer Skills & Editor Setup](#섹션-5-developer-skills--editor-setup)
  - [섹션 6: [OPTIONAL] HTML & CSS Crash Course](#섹션-6-optional-html--css-crash-course)
  - [섹션 7: JavaScript in the Browser: DOM and Events Fundamentals](#섹션-7-javascript-in-the-browser-dom-and-events-fundamentals)
  - [✅ 섹션 8: 🔥 How JavaScript Works Behind the Scenes](#-섹션-8--how-javascript-works-behind-the-scenes)
    - [JavaScript Engine and Runtime](#javascript-engine-and-runtime)
    - [Execution Contexts and The Call Stack](#execution-contexts-and-the-call-stack)
    - [Scope and The Scope Chain](#scope-and-the-scope-chain)
    - [Scoping in Practice](#scoping-in-practice)
    - [Variable Environment: Hosting and The TDZ](#variable-environment-hosting-and-the-tdz)
      - [더 알아보기](#더-알아보기)
    - [The this keyword](#the-this-keyword)
      - [더 알아보기](#더-알아보기-1)
    - [Regular Functions vs Arrow Functions](#regular-functions-vs-arrow-functions)
      - [더 알아보기](#더-알아보기-2)
    - [Primitive vs Objects(Reference Types)](#primitive-vs-objectsreference-types)
  - [섹션 9: Data Structures, Modern Operators and Strings](#섹션-9-data-structures-modern-operators-and-strings)
  - [섹션 10: 🔥 A Closer Look at Functions](#섹션-10--a-closer-look-at-functions)
  - [섹션 11: Working With Arrays](#섹션-11-working-with-arrays)
  - [섹션 12: Numbers, Dates, Intl and Timers](#섹션-12-numbers-dates-intl-and-timers)
  - [✅ 섹션 13: 🔥 Advanced DOM and Events](#-섹션-13--advanced-dom-and-events)
    - [How the DOM Really Works](#how-the-dom-really-works)
    - [Selecting, Creating, and Deleting Elements](#selecting-creating-and-deleting-elements)
    - [Styles, Attributes and Classes](#styles-attributes-and-classes)
    - [Implementing Smooth Scrolling](#implementing-smooth-scrolling)
    - [Types of Events and Event Handlers](#types-of-events-and-event-handlers)
    - [Event Propagation: Bubbling and Capturing](#event-propagation-bubbling-and-capturing)
    - [Event Delegation: Implementing Page Navigation](#event-delegation-implementing-page-navigation)
      - [더 알아보기](#더-알아보기-3)
    - [DOM Traversing](#dom-traversing)
    - [Building a Tabbed Component](#building-a-tabbed-component)
    - [Lifecycle DOM Events](#lifecycle-dom-events)
    - [Effecient Script Loading: defer and async](#effecient-script-loading-defer-and-async)
  - [섹션 14: 🔥 Object-Oriented Programming (OOP) With JavaScript](#섹션-14--object-oriented-programming-oop-with-javascript)
  - [섹션 15: Mapty App: OOP, Geolocation, External Libraries, and More!](#섹션-15-mapty-app-oop-geolocation-external-libraries-and-more)
  - [섹션 16: 🔥 Asynchronous JavaScript: Promises, Async/Await and AJAX](#섹션-16--asynchronous-javascript-promises-asyncawait-and-ajax)
    - [Asynchronous JavaScript, AJAX and APIs](#asynchronous-javascript-ajax-and-apis)
    - [Our First AJAX Call: XMLHttpRequest](#our-first-ajax-call-xmlhttprequest)
    - [How the Web Works: Reuqests and Responses](#how-the-web-works-reuqests-and-responses)
    - [✅ Welcome to Callback Hell](#-welcome-to-callback-hell)
    - [Promises and the Fetch API](#promises-and-the-fetch-api)
    - [✅ Consuming Promises](#-consuming-promises)
    - [Chaining Promises](#chaining-promises)
    - [Handling Rejected Promises](#handling-rejected-promises)
    - [✅ Throwing Errors Manually](#-throwing-errors-manually)
    - [Coding Challenge #1](#coding-challenge-1)
    - [✅ Asynchronous Behind the Scenes: The Event Loop](#-asynchronous-behind-the-scenes-the-event-loop)
    - [✅ The Event Loop in Practice](#-the-event-loop-in-practice)
    - [✅ Building a Simple Promise](#-building-a-simple-promise)
    - [✅ Consuming Promises with Async/Await](#-consuming-promises-with-asyncawait)
    - [✅ Error Handling With try...catch](#-error-handling-with-trycatch)
    - [✅ Returning Values from Async Functions](#-returning-values-from-async-functions)
    - [Returning Values from Async Functions](#returning-values-from-async-functions)
    - [Running Promises in Parallel](#running-promises-in-parallel)
    - [Other Promise Combinators: race, allSettled and any](#other-promise-combinators-race-allsettled-and-any)
  - [섹션 17: Modern JavaScript Development: Modules and Tooling](#섹션-17-modern-javascript-development-modules-and-tooling)
  - [섹션 18: Forkify App: Building a Modern Application](#섹션-18-forkify-app-building-a-modern-application)
  - [섹션 19: Setting Up Git and Deployment](#섹션-19-setting-up-git-and-deployment)
  - [섹션 20: The End!](#섹션-20-the-end)

## ❌ 복습 및 정리

## ✅ 섹션 1: Welcome, Welcome, Welcome!

> 강의 소개 내용

## ✅ 섹션 2: JavaScript Fundamentals – Part 1

javascript is a high-level object-oriented, multi-paradigm programming language.

## ✅ 섹션 3: JavaScript Fundamentals – Part 2

## ✅ 섹션 4: How to Navigate This Course

> 강의 소개 내용

## 섹션 5: Developer Skills & Editor Setup

## 섹션 6: [OPTIONAL] HTML & CSS Crash Course

## 섹션 7: JavaScript in the Browser: DOM and Events Fundamentals

## ✅ 섹션 8: 🔥 How JavaScript Works Behind the Scenes

JavaScript는 고수준의, prototype 기반의 객체지향, 멀티 패러다임, 인터프리팅되거나 just-in-time compiled되는, 동적인, 싱글 스레드인, GC 되는 프로그래밍 언어이며 함수가 1급으로 취급되며, 논 블락킹 이벤트 루프 동시성 모델을 가지고 있다.

정리하면 다음 9가지 특징으로 나눌 수 있다.

- 1. High-level
  - CPU, Memory 등의 자원을 수동으로 관리하지 않는다. (자동으로 수행)
- 2. Garbage-collected
- 3. Interpreted or just-in-time compiled
- 4. Multi-paradigm
  - 패러다임은 코드를 구조화하는 방법이나 접근법인데 대표적으로 `절차 지향 (Procedural)`, `객체 지향 (Object Oriented)`, `함수형 (Functional)` 등이 있다.
  - 또는 `Imperative` 와 `Declarative`로 나눌 수 있다.
- 5. Prototype-based object-oriented
- 6. First-class functions
- 7. Dynamic
  - 데이터 타입을 강제하지 않는다.
- 8. Single-threaded
- 9. Non-blocking event loop
  - **동시성 모델**: 자바스크립트 엔진이 어떻게 동시간에 일어나는 많은 작업을 처리할 것인가에 대한 것
  - 이는 자바스크립트가 **싱글-스레드** 기반이기 때문에 한번에 하나의 작업만 처리 가능하기 때문에 필요
  - 오래 실행되는 작업의 경우 **event loop** 를 통해 백그라운드에서 처리(실행)하고 메인 스레드로 돌려줌으로서 **논-블락킹**으로 처리

### JavaScript Engine and Runtime

- JS Engine: 자바스크립트 코드를 실행시키는 프로그램
  - 콜스택, 힙으로 구성되어있다.
    - 콜스택: 코드가 실행되어 EC가 쌓임
    - 힙: 객체가 저장되는 곳 (메모리 내부 공간)
- Compilation vs Interpretation
  - Compilation: 전체 코드가 머신 코드로 변환되고 바이너리 파일로 써짐, 그리고 컴퓨터가 실행함
  - Interpretation: 전체 코드가 라인 바이 라인으로 실행됨
  - Just-in-time(JIT) compilation: 전체 코드가 머신코드로 한번 변환되고, 그 후에 즉시 실행됨
- (현대) 자바스크립트 엔진은 다음 순서로 동작함 (그래서 실제로 인터프린팅 되진 않음)
  1. 코드 파싱 -> AST 생성
  2. AST를 컴파일해 기계 코드 생성
  3. 그리고 즉시 실행
  4. 그리고 실행 중에 백그라운드에서 계속해서 기계 코드를 최적화해서 속도를 높인다.
- 브라우저 런타임의 구성요소
  - JS엔진
  - 👉 Web APIs: 엔진에 제공되는 기능 (window 객체를 통해 접근 가능)
  - Callback Queue
  - 이벤트 루프: 논-블락킹 동시성 모델을 위한 필수 요소
- Node.js 런타임의 구성요소
  - JS엔진
  - 👉 C++ Bindings & Thread pool
  - Callback Queue
  - 이벤트 루프

### Execution Contexts and The Call Stack

- 컴파일이 끝나면?
  - 1. 전역 실행 컨텍스트가 만들어짐 (top level code에 대해서. 즉, 함수 내에 있지 않음)
  - 2. global EC안에서 top-level 코드가 실행됨
  - 3. 함수들이 실행되고 콜백을 기다림
- 정리
  - EC
    - 자바스크립트 조각이 실행되어지는 환경. 코드가 실행되는데 필요한 모든 정보를 저장한다.
  - global EC
    - 기본 컨텍스트이며, top-level. 즉, 어떤 함수내에 있지 않은 코드를 위해 만들어짐
  - 함수당 하나의 EC
    - 각 함수 호출 마다, 새로운 context가 생성된다. (call stack이 쌓인다)

EC안에서는 무엇이 일어나는가? 함수 실행전에 "creation phase"에서 다음이 만들어진다.

- 1. Variable Environment (변수 객체 또는 활성 객체 라고도 함)
  - let, const, var 선언
  - 함수
  - arguments 객체 (화살표 함수는 X)
- 2. Scope Chain
- 3. this keyword (화살표 함수는 X)

### Scope and The Scope Chain

- 스코프
  - 스코핑: 변수가 어떻게 조직(organized)되고 접근되는지(accessed)에 대한 것 (변수가 어디에 있는지, 어디에서 접근이 가능한지)
  - Lexical scoping: 스코핑은 함수와 블록의 배치에 의해 제어됨
  - Scope: 변수가 정의되는 공간 또는 환경이다. global scope, function scope, block scope가 있다.
    - 글로벌 스코프: any 함수 또는 블록 외부. 여기 정의된 변수는 모든 곳에서 접근 가능
    - 함수 스코프: 함수 내에서만 접근 가능, 외부에서 접근 불가. local scope 라고도 불림
    - 블록 스코프(ES6): 블록 내에서만 접근 가능. (let, const에만 적용). 함수 또한 block scoped임(strict mode에서만)
  - 변수의 스코프: 변수가 접근되어지는 코드의 지역을 뜻함

스코프 체인은 현재 스코프에서 접근하려는 변수를 찾을 수 없을 때 상위 스코프를 타고 올라가는 과정이다. (variable lookup in scope chain 이라고 한다)

스코프 체인은 함수의 실행 순서와 상관없이, 코드(함수)가 어디에 위치 하느냐로 EC가 만들어질 때 결정된다.

🛎 공부를 하면서 다시 해석해보면, "실행 순서와는 직접적으로 상관없지만 함수가 실행되는 위치와 코드(함수)가 코드내에 어떻게 배치되어 있느냐에 따라 EC가 생성될 때 결정된다."

### Scoping in Practice

```js
"use strict";

function calcAge(birthYear) {
  const age = 2037 - birthYear;

  function printAge() {
    const output = `${firstName}, You are ${age}, born in ${birthYear}`;
    console.log(output);

    if (birthYear >= 1981 && birthYear <= 1996) {
      var millenial = true;

      // 🤮 global scope에 정의된 걸 또 정의하기에 헷갈릴 수 있는 부분!
      // 일단 스코프 체인은 현 스코프에 없는 경우에만 탐색하기 때문에 이 블록 내부에서는 이 값을 이용할 것임
      // 함수 정의가 같은 스코프에 되지 않는 이상 다른 스코프에서는 같은 이름으로 정의가 가능함!!! (처음 알았다!)
      const firstName = "Dukgwan";

      // 외부 스코프의 변수 값을 변경 가능하다.
      output = "변경";

      const str = `You are a millenial, ${firstName}`;
      console.log(str);

      function add(a, b) {
        return a + b;
      }
    }

    console.log(millenial); // true => var는 함수 스코프를 가진다!!
    // add(2, 3); // Error, `add` is not defined => (use strict에서) 함수는 블록 스코프를 가진다!!
  }
  return age;
}

const firstName = "Gwanduke";
calcAge(1990);
```

### Variable Environment: Hosting and The TDZ

[MDN - TDZ](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone)

- var를 쓰지 말아야할 이유
  - var를 전역에서 사용하면 window 객체에 추가된다. (let, const는 그렇지 않음)

#### 더 알아보기

- [ ] 한번더 보기
- [ ] TDZ 관점으로 보았을 때, let과 const는 호이스팅된다고 볼 수 있는가?

### The this keyword

- this?
  - 모든 EC(모든 함수)에서 만들어지는 특별한 변수
  - 함수의 owner를 가르킨다.
  - 어떻게 함수가 불려지냐에 따라 다른 값을 가리키며, 실제로 호출되는 시점에만 할당됨
- this는 함수 그 자체를 가리키거나, variable env를 가리키지 않는다!!! 다음 규칙을 따름
  - mehotd: 메서드를 호출한 객체 `이 특성을 사용해 method borrowing을 할수 있다`
  - 일반 함수 호출: undefined (strict mode가 아니라면 window)
  - arrow function: 감싸는 함수 (lexical this)
  - event listener: handler가 부착된 DOM element
  - 생성자의 this: 새로 생성되는 객체

#### 더 알아보기

- [ ] 클래스의 this

### Regular Functions vs Arrow Functions

#### 더 알아보기

- [ ] 한번더 보기

### Primitive vs Objects(Reference Types)

Primitives

> 콜스택에 저장됨 (EC가 동작하는 방식을 기억하자!)

immutable

- Number
- String
- Boolean
- Undefined
- null
- Symbol
- Bigint

Objects

> heap에 저장됨

스택의 주소가 할당되고 그 주소가 힙의 주소를 가리킴(레퍼런스 타입은 스택에 담기엔 너무 크기 때문에 Heap에 넣는 것으로 설계됨)

- Object literal
- Arrays
- Functions
- ...

## 섹션 9: Data Structures, Modern Operators and Strings

## 섹션 10: 🔥 A Closer Look at Functions

## 섹션 11: Working With Arrays

## 섹션 12: Numbers, Dates, Intl and Timers

## ✅ 섹션 13: 🔥 Advanced DOM and Events

### How the DOM Really Works

- DOM은 JS <-> 브라우저 간에 상호작용을 가능하게 하는 인터페이스이다.
- JavaScript를 이용해서 HTML element를 생성/수정/삭제할 수 있고 스타일/클래스/속성/리스너를 추가하고 이벤트에 반응할 수 있다.
- DOM tree는 HTML 문서로부터 만들어진다.
  - 각 노드는 자바스크립트 Object로 표현된다.
  - 노드는 Element, Text, Comment, Document 타입으로 나뉜다. 다음과 같은 타입이 제공되며 상위 타입의 프로퍼티와 메서드를 상속받는다.

```plain
                  EventTarget (.addEventListener...)
                      |
                  ---------------------
                  |                   |
                 Node               Window (Global)
                  |
   ----------------------------------
   |          |         |           |
Element    Text     Comment    Document
   |
HTMLElement
|  |  |  |
HTMLButtonElement, HTMLDivElement...
```

### Selecting, Creating, and Deleting Elements

```js
/* 
  Selecting Elements
*/
document.documentElement;
document.head;
document.body;
document.querySelector(".header");
document.querySelectorAll(".section");
document.getElementById("my-id");
document.getElementsByTagName("button");
document.getElementsByClassName("btn");

/* 
  Creating, inserting elements 
*/
insertAdjacentHTML;
const messageDiv = document.createElement("div"); // DOM Object, 하지만 아직 DOM에 부착되진 않음
messageDiv.classList.add("cookie-message");
// message.textContent = 'We use cookie';
message.innerHTML = 'We use cookie. <button class="btn">Got it!</button>';

// child
header.prepend(message);
header.append(message);
header.append(message.cloneNode(true));

// sibling
header.before(message);
header.after(message);

/*
  Delete elements
*/
document.querySelector(".btn").addEventListener("click", () => {
  // message.remove();
  message.parentElement.removeChild(message);
});
```

### Styles, Attributes and Classes

```js
// Styles
message.style.backgroundColor = "#373737";
getComputedStyle(message).color; // 실제로 브라우저에서 계산된 스타일

logo.src; // http://127.0.0.1/img/logo.png
logo.getAttribute("src"); // img/logo.png

logo.dataset.versionNumber; // <img data-version-number="something" />

logo.classList.add(...);
logo.classList.remove(...);
logo.classList.toggle(...);
logo.classList.containes(...);
```

### Implementing Smooth Scrolling

```js
scrollButton.addEventListener("click", function (e) {
  target.getBoundingClientRect(); // viewport에 기반한 x, y, left, width 등의 값

  // .top, .y는 document가 아니라 현재 보고있는 viewport에 기반하므로 위치에 따라 바뀜을 고려
  window.scrollTo({
    left: target.left + window.pageXOffset,
    top: target.top + window.pageYOffset,
    behavior: "smooth",
  });

  // == (and modern way)
  target.scrollIntoView({ behavior: "smooth" });
});
```

### Types of Events and Event Handlers

https://developer.mozilla.org/ko/docs/Web/Events

```js
const callback = () => {};
el.addEventListener("mouseenter", callback); // 추천되는 방법, 여러 이벤트를 달 수 있음
el.onmouseenter = callback;
el.removeEventListener("mouseenter", callback);
```

### Event Propagation: Bubbling and Capturing

- 이벤트 발생 과정
  1. Capturing Phase
  2. target element까지 탐색 (target Phase)
  3. Bubbling Phase
- `stopPropagation`을 하는 것은 좋은 생각이 아니다. 이벤트가 부모까지 전달되지 않으므로 분석툴 같은 것을 사용할 때 문제가 생길 수 있다.

### Event Delegation: Implementing Page Navigation

리스트의 아이템에 모두 이벤트를 다는 것은 개수가 많아짐에 따라 비효율적일 수 있는데, 이벤트가 전파된다는 특성을 이용하면 부모 DOM에서 한번만 이벤트를 등록함으로서 효율적으로 처리할 수 있다. (그렇지 않으면 성능 이슈가 있을 수 있다)

#### 더 알아보기

- [ ] 리액트에서는 Event Delegation을 어떻게 수행할까? MUI에서 Tabs, Tab 같은 API가 이를 이용해 구성되었던가?
  - https://github.com/facebook/react/issues/13635
  - https://ui.toast.com/weekly-pick/ko_20160826

### DOM Traversing

```js
// downwards
h1.childNodes; // text, comment 노드를 포함한 모든 노드
h1.children; // elements
h1.fistElementChild.style.color = "white";
h1.lastElementChild.style.color = "white";

// upwards
h1.parentNode;
h1.parentElement;
h1.closest(".header");

// sideways
h1.previousElementSibling;
h1.nextElementSibling;
h1.previousSibling;
h1.nextSibling;
h1.parentElement.children;
[...h1.parentElement.children].forEach((el) => el !== h1 && el.something());
```

### Building a Tabbed Component

### Lifecycle DOM Events

- DOMContentLoaded: DOM이 완성되자 마자 콜백 수행
- load: DOM이 완성되고 모든 외부 리소스(이미지, CSS 등)이 로드가 완료 되었을 때 콜백 수행
- beforeunload: 현재 창을 떠날 때, 전체 페이지가 unload되기 전

  ```js
  window.addEventListener("beforeunload", function (e) {
    e.preventDefault();
    console.log(e);
    e.returnValue = ""; // 예전에는 메시지를 변경할 수 있었지만, 현재 브라우저는 변경 불가함
  });
  ```

### Effecient Script Loading: defer and async

head의 `<script />`

```plain
// ---------- 시간 ---------->
| Parsing HTML |       waiting...       | Finish parsing HTML |
               | Fetch script | Execute |                     ✅ DOMContentLoaded
```

body 끝의 `<script />`

```plain
|           Parsing HTML           | Fetch script | Execute |
                                                            ✅ DOMContentLoaded
```

head의 `<script async />`

```plain
|     Parsing HTML   | waiting | Finish parsing HTML |
      | Fetch script | Execute |                     ✅ DOMContentLoaded
```

head의 `<script defer />`

```plain
|           Parsing HTML           | Execute |
      | Fetch script |                       ✅ DOMContentLoaded
```

async, defer가 body 끝에서 쓰이는 것은 말이 되지 않음 (키워드 없이 쓴것과 동일)

- 일반 태그는 이전 브라우저를 지원하기 위해서 사용
- async
  - 순서대로 실행됨을 보장하지 않음
  - DOMContentLoaded는 async 스크립트 다운로드/실행을 기다리지 않음
  - 구글 애널리틱스 같은 3rd-party 스크립트를 사용할 때 유용
  - fetch가 DOM 생성시점보다 길어지는 경우, DOMContentLoaded가 더 빨리 일어남
- defer
  - DOMContentLoaded는 defer 스크립트의 실행 이후에 일어남
  - 순서대로 실행됨을 보장함
  - 직접 작성한 스크립트와 순서가 중요한 스크립트는 defer 처리해주는 것이 좋음

## 섹션 14: 🔥 Object-Oriented Programming (OOP) With JavaScript

## 섹션 15: Mapty App: OOP, Geolocation, External Libraries, and More!

## 섹션 16: 🔥 Asynchronous JavaScript: Promises, Async/Await and AJAX

### Asynchronous JavaScript, AJAX and APIs

- Synchronous
  - 대부분의 코드는 동기적
  - 코드가 라인 바이 라인으로 실행됨
  - 이전 라인이 끝나기 전까지 기다림 (블락킹)
  - 긴 작업이 코드 실행을 block
- Asynchronoous

  - non-blocking
  - 콜백 함수 그 자체가 비동기를 만드는 것이 아님

- AJAX: 원격 웹 서버와 비동기적으로 통신할 수 있게 한다. AJAX 호출을 이용하면, 웹서버의 데이터를 동적으로 요청할 수 있다.
- API: Application Programming Interface, 어플리케이션 간에 각자 대화를 허용하기 위해 만듬 (DOM API, Geolocation API, own class API...)

### Our First AJAX Call: XMLHttpRequest

실습 -> [코드](./complete-javascript-course/16-Asynchronous/starter/script.js)

### How the Web Works: Reuqests and Responses

1. Client -> URL -> DNS Lookup -> get IP!
2. 서버와 TCP/IP 소켓 커넥션 수행
   - TCP의 역할은 데이터를 잘게 패킷으로 쪼개 목적지로 전달한다. 인터넷 상에서 그 경로는 서로 다를 수 있다.
   - IP는 이 패킷들이 인터넷을 통해 전송되고 라우트 되도록 한다.
3. 클라이언트가 HTTP Request 수행. 구성은 다음과 같다. HTTPS는 TLS 또는 SSL로 암호화를 수행함

   ```plain
   GET /rest/v2/alpha/PT HTTP/1.1   // 메서드 + 타겟 + 버전

   Host: www.google.com             // 요청 헤더
   User-Agent: Mozilla/5.0

   <BODY>                           // 요청 본문
   ```

4. HTTP 응답 전달

   ```plain
   HTTP/1.1 200 OK         // 버전 + 상태코드 + 상태메시지

   Date: Fri, 18 Jan 2021  // 응답 헤더
   Content-Type: text/html

   <BODY>                  // 응답 본문
   ```

### ✅ Welcome to Callback Hell

### Promises and the Fetch API

- Promise
  - 비동기 작업으로 인한 미래의 결과를 담는 객체
  - 간단하게 말하면, "미래의 값을 위한 컨테이너"
- Promise를 사용하면
  - 비동기 결과를 제어하기 위해 더이상 콜백이나 이벤트에 의존할 필요가 없다.
  - Promise를 체이닝하여, callback hell을 피할 수 있다.

```plain
PENDING -----------------> SETTLED (async task finished)
           async task      |      \
                        FULFILLED  REJECTED
                        (success)  (failed)
```

### ✅ Consuming Promises

### Chaining Promises

- Promise를 계속 체인하면서 핸들링할 수 있다.

```js
fetch()
  .then((res) => res.json())
  .then((data) => fetch())
  .then((res) => res.json); // so on...
```

### Handling Rejected Promises

- `.catch` 메서드는 프로미스 체인 내에 발생하는 어떤 에러든 핸들링한다.
  - 또한 catch는 promise를 리턴한다.
- `.finally`

### ✅ Throwing Errors Manually

필요한 경우 `throw new Error`를 통해 처리

### Coding Challenge #1

- [ ] TODO:

### ✅ Asynchronous Behind the Scenes: The Event Loop

- Promise와 관련된 콜백은 마이크로 태스크 큐로 들어가며, 이는 Callback Queue(Task Queue)보다 항상 우선되어 수행된다. 혹시나 마이크로 태스크의 작업이 Promise 콜백을 유발하면 또다시 마이크로 태스크가 계속 쌓여 Callback Queue의 작업이 진행되지 않을 수도 있다.

### ✅ The Event Loop in Practice

```js
console.log("1");
setTimeout(() => console.log("timeout"), 0);
Promise.resolve("Resolved").then((res) => console.log(res));
console.log("2");
```

### ✅ Building a Simple Promise

`new Promise`로 Promise를 만들 수 있다.

### ✅ Consuming Promises with Async/Await

> ES2018 feature

- async/await는 동기코드인 것처럼 보이지만, 뒷단 구동은 비동기로 동작한다.

### ✅ Error Handling With try...catch

### ✅ Returning Values from Async Functions

async 함수가 반환하는 것은 Promise임을 기억하자

### Returning Values from Async Functions

아래와 같은 경우는 헷갈릴 소지가 있는데 조심해야겠다.

```js
const example = async () => {
  try {
    throw new Error("Error!");
    return "Resolved";
  } catch (err) {
    console.error(err);
    // throw err;
  }
};

example()
  .then((rst) => {
    console.log("[2] then: ", rst); // throw 해주지 않으면 여기가 실행됨
  })
  .catch((err) => {
    console.error("[2] catch: ", err); // 올바른 결과를 도출하려면 re-throw
  });
```

### Running Promises in Parallel

`Promise.all`을 사용하면 병렬로 수행할 수 있다. 다만 하나라도 reject되면 Promise.all은 reject처리 된다.

### Other Promise Combinators: race, allSettled and any

- `Promise.race`: 가장 먼저 settle(resolve or reject)된 Promise를 반환. 하지만 네트워크 요청은 취소되지 않음을 기억하자
- `Promise.allSettled` (ES2020): Promise.all과 비슷하지만 reject되더라도 반환한다.
- `Promise.any` (ES2021): Promise.race과 동일하나 reject된 것은 무시

## 섹션 17: Modern JavaScript Development: Modules and Tooling

## 섹션 18: Forkify App: Building a Modern Application

## 섹션 19: Setting Up Git and Deployment

## 섹션 20: The End!

<!-- ## 섹션 21:[LEGACY] Access the Old Course
## 섹션 22:[LEGACY - REMOVED SOON] JavaScript Language Basics
## 섹션 23:[LEGACY - REMOVED SOON] How JavaScript Works Behind the Scenes
## 섹션 24:[LEGACY - REMOVED SOON] JavaScript in the Browser: DOM Manipulation and Events
## 섹션 25:[LEGACY - REMOVED SOON] Advanced JavaScript: Objects and Functions
## 섹션 26:[LEGACY - REMOVED SOON] Putting It All Together: The Budget App Project -->
