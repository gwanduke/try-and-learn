# 2022년 8월

## 읽을거리

- JavaScript
  - [ ] [JavaScript Event Loop And Call Stack Explained](https://felixgerschau.com/javascript-event-loop-call-stack)
  - [ ] [JavaScript's Memory Management Explained](https://felixgerschau.com/javascript-memory-management)
  - [ ] [The Latest ES13 JavaScript Features](https://javascript.plainenglish.io/latest-es13-javascript-features-24cba45c93f7)
- React
  - [ ] [Examples of Large Production Grade Open Source React Apps](https://maxrozen.com/examples-of-large-production-grade-open-source-react-apps)
  - [ ] [Applying SOLID principles in React](https://medium.com/dailyjs/applying-solid-principles-in-react-14905d9c5377)
  - [ ] [Kent C. Dodds Blog](https://kentcdodds.com/blog)

## Node.js Server Best Practices

대용량 서버 운영

- PM2

### 모니터링

- CPU, 서버 메모리, Node 프로세스 메모리 (1.4GB 미만), 마지막 1분 동안 에러의 수, 프로세스가 재시작한 횟수, 평균 응답 시간 등

주요지표

- 에러율: 에러는 사용자에게 직접 노출되기 때문에, 고객들이 즉시 영향을 받습니다.
- 응답시간: 늦은 응답시간은 고객과 비즈니스에 직접적인 영향을 줍니다.
- 처리율: 트래픽은 에러율과 지연시간이 커지는 원인을 파악하는데 도움을 줍니다.
- 포화싱테: 서비스가 얼마나 “가득”찼는지 알려줍니다. CPU 사용량이 90%인 시스템이 더 많은 트래픽을 처리 할 수 있을까요?

### 로깅

1. 각 로그 라인에 타임스탬프를 기록하여 각각의 로그가 언제 발생했는지 알 수 있어야 합니다.
2. 로깅 포맷은 인간뿐만 아니라 기계에 의해서도 쉽게 처리될 수 있어야 합니다.
3. 여러 목적지를 대상으로 설정 할 수 있도록 스트림을 사용해야 합니다. 예를 들어, 파일에 추적 로그를 기록하면서, 에러가 발생하면 추가로 오류 파일에도 기록을 하고 이메일까지 발송하는 것 처럼 말입니다.

### 팁

- 가능한 모든 것들(예: gzip, SSL)을 reverse proxy에 위임하기
- Node는 압축, SSL 종료 등 CPU에 민감한 작업을 하기에는 적당하지 않습니다. nginx, HAProxy, 기타 클라우드 서비스와 같은 “진짜” 미들웨어 서비스를 사용하세요.
- 정적 파일 제공, gzip 인코딩, 요청 쓰로틀링, SSL 종료 등과 같은 네트워크 관련 작업들에 대해 Express의 풍부한 미들웨어를 사용하고 싶어지는 유혹은 클 수 있습니다. 이런 작업들은 CPU를 오랫동안 바쁘게 구동시켜야 하기 때문에 싱글 쓰레드 모델에서는 성능 저하가 발생 ( Node의 실행 모델은 짧은 작업 또는 비동기 IO 작업에 최적화 되어 있습니다) 더 나은 접근 방식은 네트워킹 작업을 전문적으로 처리하는 도구를 사용하는 것입니다. 가장 널리 사용되는 도구로는 nginx와 HAproxy가 있습니다
- Node는 웹 서버가 아닙니다. 애플리케이션에 접속이 들어오자마자 문제가 발생하기 시작합니다. 연결이 끊어지거나 asset 제공이 갑자기 멈추고, 최악의 경우 서버가 다운됩니다. 여러분이 지금 하고 있는 것은, 이미 입증 된 웹 서버들이 정말 잘하는 복잡한 작업들을 Node 혼자 처리하도록 하는 것입니다. 왜 바퀴를 다시 발명합니까? 애플리케이션은 데이터베이스를 읽거나 복잡한 로직을 수행하는 것 같은 중요한 작업을 위해 사용되어야 한다는 것을 기억해야… Express.js는 미들웨어를 통해 정적 파일들을 처리하는 기능을 내장하고 있지만 결코 사용해서는 안됩니다. Nginx는 정적 파일을 다루는 작업을 훨씬 더 잘 수행 할 수 있으며 비동기 컨텐츠에 대한 요청으로 Node 프로세스가 먹통이 되는 것을 막을 수 있습니다.
- Node는 장애가 발생하면 기본적으로 프로세스가 보호 받고 재시작이 가능해야합니다. 컨테이너를 사용하지 않고 조그만 애플리케이션을 만드는 개발자에게 PM2는 복잡하지 않으면서도 재시작이 기능하고 Node와의 풍부한 통합을 제공하기 때문에 안성맞춤입니다. 뛰어난 Linux 기술을 가진 사람들은 systemd를 사용해서 Node를 서비스로 실행할 수 있습니다. Docker 등의 컨테이너 기술을 사용하는 앱의 경우 일반적으로 함께 제공되는 클러스터 관리 도구(예: AWS ECS, Kubernetes 등)로 모니터링을 하거나 스스로 컨테이너를 회복시키는 기능을 이용 할 수 있습니다. 풍부한 클러스터 관리 기능에 컨테이너의 재시작 기능까지 있는데, PM2 같은 다른 도구를 굳이 사용해서 문제를 어렵게 만들 필요가 있을까요? 그에 대해 확답을 내리기는 힘듭니다. 프로세스를 가장 앞에서 보호해 줄 녀석으로 PM2를(컨테이너 전용 버전으로 pm2-docker가 대부분 사용됨) 사용해야 하는 좋은 이유가 있습니다. 프로세스를 재시작 하는 것은 컨테이너의 재시작보다 훨씬 빠르고, 호스팅 컨테이너가 우아한(graceful) 재시작을 요청 할 때, 서버에 플래그를 지정하는 것처럼 Node에 특화된 기능들을 제공하기 때문입니다. 어떤 이들은 불필요한 레이어를 만드는 것을 원하지 않을 수도 있습니다. 이 쯤에서 정리하겠습니다. 모두에게 딱 맞는 해결책은 없습니다. 다만 어떤 옵션이 있는지는 알고 있어야 합니다.
- 모든 CPU 코어 활용하기! - Node는 기본적으로 단일 CPU 코어에서 실행되고 다른 모든 프로그램은 유휴(idle) 상태가 됩니다. 여러 Node 프로세스를 띄워서 모든 CPU를 활용하는 것은 선택이 아니라 필수입니다. 중형 애플리케이션의 경우 Node 클러스터 또는 PM2를 사용할 수도 있습니다. 보다 큰 애플레키에션에서는 Docker 클러스터(예: K8S, ECS) 또는 Linux init 시스템(예: systemd)을 기반으로 하는 배포 스크립트를 사용해서 프로세스를 복제하는 것이 좋습니다.
- Node가 단일 스레드=단일 프로세스=단일 CPU로 실행된다는 것은 놀랄 일도 아닙니다4개 또는 8개의 CPU가 있는 비싼 하드웨어를 사서 단 한 개만 사용한다는 건 그냥 개념이 없는 겁니다. 중간 규모의 애플리케이션에게 가장 적당하고 빠르게 적용 할 수 있는 해결책은 Node의 클러스터 모듈을 사용하는 것입니다. 이 모듈은 10줄의 코드만으로 각각의 코어에 프로세스를 생성하고 라운드 로빈 방식으로 프로세스간 요청을 라우팅합니다. 더 좋은 방법은 간단한 인터페이스와 멋진 모니터링 UI로 클러스터링 모듈을 사용 가능한 PM2를 사용하는 것입니다. -> 하지만 더 높은 성능이 요구된다면 cluster 보다는 nginx로 로드 밸런싱하자. (성능 좋음)

9. APM 제품을 사용하여 오류 및 다운타임 발견하기
   제품의 성능을 모니터링하는 제품(APM이라고도 함)
10. Node에서 프론트엔드 asset 가져 오기
    단일 스레드 모델로 인해 많은 정적 파일들을 처리 할 때 Node의 성능이 실제로 저하되기 때문에 전용 미들웨어(nginx, S3, CDN)를 사용하여 프론트엔드의 컨텐츠를 제공해야합니다. 아니라면…: 수백개의 html/image/angular/react 파일들을 스트리밍하느라 정작 동적 컨텐츠를 제공하라고 만들어진 Node의 단일 쓰레드는 매우 바빠질 겁니다.

다음 중 하나의 최적 솔루션을 사용 할 수 있습니다.

Reverse Proxy: 정적 파일들은 Node의 코드들과 같은 레벨에 위치하며, 정적 파일 폴더에 대한 요청만 Node 앞에 있는 Nginx 같은 Proxy에 의해 처리됩니다. 이 방식을 사용하면 Node 애플리케이션이 정적 파일을 배포하는 책임은 갖지만, 실제로 전달하는 역할은 하지 않습니다. 여러분의 프론트엔드 동료는 cross-origin 요청을 방지 할 수 있으므로, 이 방식을 무척 좋아할 것입니다.
Cloud Storage: 정적 파일은 Node 앱 콘텐츠의 일부가 아니며 AWS S3, Azure Blob Storage 또는 이러한 목적을 위해 탄생 한 다른 클라우드 서비스에 업로드됩니다. 이 방식을 사용하면 Node가 정적 파일의 배포를 책임지지 않기 때문에, 각자 다른 팀에서 처리한다 하더라도 Node와 프론트엔드간에 완벽한 디커플링이 되기 때문에 문제가 되지 않습니다.

16. 각 로그 트랜잭션 문에 ‘TransactionId’ 지정하기

### 참고 사이트

- https://blog.ull.im/engineering/2019/03/31/node-js-production-best-practices.html
- https://expressjs.com/en/advanced/best-practice-performance.html
- https://goldbergyoni.com/checklist-best-practices-of-node-js-error-handling/
- [ ] https://engineering.linecorp.com/ko/blog/pm2-nodejs
- [ ] https://12factor.net/
- [ ] https://www.youtube.com/watch?v=lUsNne-_VIk
- [ ] https://medium.com/@fermads/node-js-process-load-balancing-comparing-cluster-iptables-and-nginx-6746aaf38272
- [ ] https://medium.com/@CodeAndBiscuits/understanding-nodejs-clustering-in-docker-land-64ce2306afef#.cssigr5z3
- [ ] https://nodejs.org/en/docs/guides/dont-block-the-event-loop/
- [ ] https://www.nginx.com/blog/5-performance-tips-for-node-js-applications/

Nodejs as Proxy

- [ ] https://javascript.plainenglish.io/build-your-own-forward-and-reverse-proxy-server-using-node-js-from-scratch-eaa0f8d69e1f
- 재밌는 이슈: https://github.com/http-party/node-http-proxy/issues/1058
-

### 키워드

- nodejs cluster: NodeJS는 단일 스레드. 서버의 CPU개수에 맞춰 여러 워커를 띄워 서버 운영
- 개발시에는 Nodemon, 운영에서는 strongloop pm2 forever
-

### Tools

- Grafana: UI 레이어

### 오류관리 best practices

### Nextjs와 heavy traffic

- https://stackoverflow.com/questions/71584898/behavior-of-nextjs-app-under-heavy-traffic
  - Nodejs는 싱글스레드이지만, 비동기 콜은 Lib UV thread pool 에서 실행된다. Nodejs가 IO를 기다릴 때 LibUV가 뒤에서 돌고있다. LibUV Thread가 꽉차면 NodeJS는 Thread가 이용가능하여 또다른 IO 작업이 시작될 수 있을 때 까지 기다린다. 이 때 모든게 느려질 수 있다. 보통 thread pool의 기본값은 4인데, 이 설정값을 올리는 것은 도움이 될 수 있다.
  - 도커에서의 성능은 CPU bound와 IO bound 에 달하면 단순히 도커 인스턴스 수를 아무리 늘려도 소용없다. 이 떄에는 서버 머신을 scale up 하거나 더 많은 머신을 사용해야한다.

### Nextjs 앱 모니터링

- [ ] https://panelbear.com/blog/monitoring-nextjs-apps/

### Sentry

https://sentry.io/for/nextjs/

### Nextjs 특징

- [x] https://geonlee.tistory.com/229
- https://yceffort.kr/2020/10/nextjs-10

### Nextjs 에서의 에러핸들링

- https://yceffort.kr/2021/10/api-error-handling-nextjs
- Server
  - \_error page
  - return `{ redirect }` or `{ notFound: true }`
- Client
  - Error Boundary

### 에러 핸들링

- [프론트엔드 핸드북 - Error Handling](https://infinum.com/handbook/frontend/react/recipes/error-handling)
-
